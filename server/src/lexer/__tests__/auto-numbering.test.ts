/**
 * Lexer Tests - Auto-Numbering (@number) Handling
 *
 * Tests tokenization of C/AL auto-numbering syntax (Identifier@Number).
 * This syntax is generated by C/SIDE and appears in:
 * - Procedure names: PROCEDURE Name@1()
 * - Parameter names: (Param@1000 : Code[20])
 * - Variable names: Variable@1001 : Integer;
 * - Field names (in FIELDS section)
 *
 * REGRESSION TESTS for Issue #XX:
 * - Parser error with procedure @numbers followed by parameters
 * - @ character tokenized as Unknown instead of proper token
 */

import { Lexer } from '../lexer';
import { TokenType } from '../tokens';

describe('Lexer - Auto-Numbering (@number) Handling', () => {
  describe('@ character tokenization', () => {
    it('should tokenize @ character', () => {
      const code = '@';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens).toHaveLength(2); // @ + EOF
      // Currently produces Unknown - this test documents current behavior
      // TODO: Should @ be a proper token type? Or part of identifier?
      expect(tokens[0].type).toBe(TokenType.Unknown);
      expect(tokens[0].value).toBe('@');
    });

    it('should tokenize @ followed by number', () => {
      const code = '@1';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens).toHaveLength(3); // @ + number + EOF
      expect(tokens[0].type).toBe(TokenType.Unknown); // @
      expect(tokens[0].value).toBe('@');
      expect(tokens[1].type).toBe(TokenType.Integer);
      expect(tokens[1].value).toBe('1');
    });

    it('should tokenize @ followed by large number', () => {
      const code = '@1000';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens).toHaveLength(3); // @ + number + EOF
      expect(tokens[0].type).toBe(TokenType.Unknown); // @
      expect(tokens[1].type).toBe(TokenType.Integer);
      expect(tokens[1].value).toBe('1000');
    });
  });

  describe('Identifier@Number patterns', () => {
    it('should tokenize procedure name with @number', () => {
      const code = 'PROCEDURE Indent@1';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Procedure);
      expect(tokens[1].type).toBe(TokenType.Identifier);
      expect(tokens[1].value).toBe('Indent');
      expect(tokens[2].type).toBe(TokenType.Unknown); // @
      expect(tokens[2].value).toBe('@');
      expect(tokens[3].type).toBe(TokenType.Integer);
      expect(tokens[3].value).toBe('1');
    });

    it('should tokenize procedure name with @number followed by parameters', () => {
      // REGRESSION TEST: This pattern causes "Unexpected token in parameter list"
      const code = 'PROCEDURE Indent@1(JobNo@1000 : Code[20])';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Procedure);
      expect(tokens[1].type).toBe(TokenType.Identifier); // Indent
      expect(tokens[2].type).toBe(TokenType.Unknown); // @
      expect(tokens[3].type).toBe(TokenType.Integer); // 1
      expect(tokens[4].type).toBe(TokenType.LeftParen);
      expect(tokens[5].type).toBe(TokenType.Identifier); // JobNo
      expect(tokens[6].type).toBe(TokenType.Unknown); // @
      expect(tokens[7].type).toBe(TokenType.Integer); // 1000
      expect(tokens[8].type).toBe(TokenType.Colon);
    });

    it('should tokenize variable declaration with @number', () => {
      const code = 'Customer@1001 : Record 18;';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Identifier); // Customer
      expect(tokens[0].value).toBe('Customer');
      expect(tokens[1].type).toBe(TokenType.Unknown); // @
      expect(tokens[1].value).toBe('@');
      expect(tokens[2].type).toBe(TokenType.Integer); // 1001
      expect(tokens[2].value).toBe('1001');
      expect(tokens[3].type).toBe(TokenType.Colon);
    });

    it('should tokenize array variable with @number', () => {
      // REGRESSION TEST: From COD1003.TXT line 39
      const code = 'JTNo@1008 : ARRAY [10] OF Code[20];';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Identifier); // JTNo
      expect(tokens[0].value).toBe('JTNo');
      expect(tokens[1].type).toBe(TokenType.Unknown); // @
      expect(tokens[1].value).toBe('@');
      expect(tokens[2].type).toBe(TokenType.Integer); // 1008
      expect(tokens[2].value).toBe('1008');
      expect(tokens[3].type).toBe(TokenType.Colon);
      expect(tokens[4].type).toBe(TokenType.Array);
    });

    it('should tokenize multiple parameters with @numbers', () => {
      const code = '(Param1@1000 : Code[20];Param2@1001 : Integer)';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      // First parameter: ( Param1 @ 1000 : Code [ 20 ] ; ...
      // Position:       0   1    2   3   4   5   6  7  8 9
      expect(tokens[1].type).toBe(TokenType.Identifier); // Param1
      expect(tokens[2].type).toBe(TokenType.Unknown); // @
      expect(tokens[3].type).toBe(TokenType.Integer); // 1000
      expect(tokens[4].type).toBe(TokenType.Colon); // :
      expect(tokens[5].type).toBe(TokenType.Code_Type); // Code data type (after colon)
      expect(tokens[6].type).toBe(TokenType.LeftBracket); // [

      // Semicolon separator is at position 9 after ]
      expect(tokens[9].type).toBe(TokenType.Semicolon);

      // Second parameter starts at position 10
      expect(tokens[10].type).toBe(TokenType.Identifier); // Param2
      expect(tokens[11].type).toBe(TokenType.Unknown); // @
      expect(tokens[12].type).toBe(TokenType.Integer); // 1001
    });

    it('should tokenize VAR parameter with @number', () => {
      const code = 'VAR Customer@1000 : Record 18';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Var);
      expect(tokens[1].type).toBe(TokenType.Identifier); // Customer
      expect(tokens[2].type).toBe(TokenType.Unknown); // @
      expect(tokens[3].type).toBe(TokenType.Integer); // 1000
    });
  });

  describe('Real-world patterns from C/AL code', () => {
    it('should tokenize typical local variable declarations', () => {
      const code = `
        Window@1007 : Dialog;
        JTNo@1008 : ARRAY [10] OF Code[20];
        i@1009 : Integer;
      `;
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      // Find Window variable
      const windowIdx = tokens.findIndex(t => t.value === 'Window');
      expect(tokens[windowIdx].type).toBe(TokenType.Identifier);
      expect(tokens[windowIdx + 1].type).toBe(TokenType.Unknown); // @
      expect(tokens[windowIdx + 2].value).toBe('1007');

      // Find JTNo array variable
      const jtNoIdx = tokens.findIndex(t => t.value === 'JTNo');
      expect(tokens[jtNoIdx].type).toBe(TokenType.Identifier);
      expect(tokens[jtNoIdx + 1].type).toBe(TokenType.Unknown); // @
      expect(tokens[jtNoIdx + 2].value).toBe('1008');

      // Find i variable
      const iIdx = tokens.findIndex(t => t.value === 'i');
      expect(tokens[iIdx].type).toBe(TokenType.Identifier);
      expect(tokens[iIdx + 1].type).toBe(TokenType.Unknown); // @
      expect(tokens[iIdx + 2].value).toBe('1009');
    });

    it('should tokenize procedure with [External] attribute and @number', () => {
      // REGRESSION TEST: From COD1003.TXT lines 42-43
      const code = `
        [External]
        PROCEDURE Indent@1(JobNo@1000 : Code[20]);
      `;
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      const procIdx = tokens.findIndex(t => t.type === TokenType.Procedure);
      expect(tokens[procIdx + 1].type).toBe(TokenType.Identifier); // Indent
      expect(tokens[procIdx + 1].value).toBe('Indent');
      expect(tokens[procIdx + 2].type).toBe(TokenType.Unknown); // @
      expect(tokens[procIdx + 2].value).toBe('@');
      expect(tokens[procIdx + 3].type).toBe(TokenType.Integer); // 1
      expect(tokens[procIdx + 3].value).toBe('1');
      expect(tokens[procIdx + 4].type).toBe(TokenType.LeftParen);
    });

    it('should tokenize field declaration with @number in FIELDS section', () => {
      const code = `
        FIELDS
        {
          { 1   ;   ;No.@1001          ;Code20        }
        }
      `;
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      // "No." is tokenized as "No" + "." (two tokens)
      const noIdx = tokens.findIndex(t => t.value === 'No');
      expect(noIdx).toBeGreaterThan(-1); // Found "No"
      expect(tokens[noIdx].type).toBe(TokenType.Identifier);
      expect(tokens[noIdx + 1].type).toBe(TokenType.Dot); // .
      expect(tokens[noIdx + 2].type).toBe(TokenType.Unknown); // @
      expect(tokens[noIdx + 3].value).toBe('1001');
    });
  });

  describe('Edge cases', () => {
    it('should handle @ at end of input', () => {
      const code = 'Variable@';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Identifier);
      expect(tokens[1].type).toBe(TokenType.Unknown); // @
      expect(tokens[2].type).toBe(TokenType.EOF);
    });

    it('should handle @ followed by non-number', () => {
      const code = 'Variable@Name';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Identifier); // Variable
      expect(tokens[1].type).toBe(TokenType.Unknown); // @
      expect(tokens[2].type).toBe(TokenType.Identifier); // Name
    });

    it('should handle multiple @@ symbols', () => {
      const code = 'Variable@@1000';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Identifier); // Variable
      expect(tokens[1].type).toBe(TokenType.Unknown); // @
      expect(tokens[2].type).toBe(TokenType.Unknown); // @
      expect(tokens[3].type).toBe(TokenType.Integer); // 1000
    });

    it('should handle @number in middle of identifier (invalid but should tokenize)', () => {
      const code = 'Vari@123able';
      const lexer = new Lexer(code);
      const tokens = lexer.tokenize();

      expect(tokens[0].type).toBe(TokenType.Identifier); // Vari
      expect(tokens[1].type).toBe(TokenType.Unknown); // @
      expect(tokens[2].type).toBe(TokenType.Integer); // 123
      expect(tokens[3].type).toBe(TokenType.Identifier); // able
    });
  });
});
