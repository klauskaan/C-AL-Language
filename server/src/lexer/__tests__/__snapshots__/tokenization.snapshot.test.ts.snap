// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`Lexer Tokenization Snapshots Context-Dependent Tokenization should tokenize BEGIN/END in OptionCaptionML brackets as identifiers 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Test"
LEFT_BRACE:"{"
FIELDS:"FIELDS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
INTEGER:"1"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"Status"
SEMICOLON:";"
OPTION:"Option"
SEMICOLON:";"
IDENTIFIER:"OptionCaptionML"
EQUAL:"="
LEFT_BRACKET:"["
IDENTIFIER:"ENU"
EQUAL:"="
IDENTIFIER:"Begin"
COMMA:","
IDENTIFIER:"End"
COMMA:","
IDENTIFIER:"Processing"
RIGHT_BRACKET:"]"
SEMICOLON:";"
IDENTIFIER:"OptionString"
EQUAL:"="
IDENTIFIER:"Begin"
COMMA:","
IDENTIFIER:"End"
COMMA:","
IDENTIFIER:"Processing"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Context-Dependent Tokenization should tokenize BEGIN/END in property values as identifiers 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Test"
LEFT_BRACE:"{"
PROPERTIES:"PROPERTIES"
LEFT_BRACE:"{"
IDENTIFIER:"InitValue"
EQUAL:"="
IDENTIFIER:"Begin"
SEMICOLON:";"
IDENTIFIER:"TestValue"
EQUAL:"="
IDENTIFIER:"End"
SEMICOLON:";"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Context-Dependent Tokenization should tokenize braces as comments in CODE context (swallowed from token stream) 1`] = `
"OBJECT:"OBJECT"
CODEUNIT:"Codeunit"
INTEGER:"50000"
IDENTIFIER:"Test"
LEFT_BRACE:"{"
CODE:"CODE"
LEFT_BRACE:"{"
PROCEDURE:"PROCEDURE"
IDENTIFIER:"DoSomething"
UNKNOWN:"@"
INTEGER:"1"
LEFT_PAREN:"("
RIGHT_PAREN:")"
SEMICOLON:";"
BEGIN:"BEGIN"
IDENTIFIER:"MESSAGE"
LEFT_PAREN:"("
STRING:"Hello"
RIGHT_PAREN:")"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
BEGIN:"BEGIN"
END:"END"
DOT:"."
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Context-Dependent Tokenization should tokenize braces as structural tokens in PROPERTIES values 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Customer"
LEFT_BRACE:"{"
PROPERTIES:"PROPERTIES"
LEFT_BRACE:"{"
IDENTIFIER:"Caption"
EQUAL:"="
LEFT_BRACE:"{"
IDENTIFIER:"This"
IDENTIFIER:"is"
IDENTIFIER:"a"
IDENTIFIER:"comment"
RIGHT_BRACE:"}"
SEMICOLON:";"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Context-Dependent Tokenization should tokenize keywords as identifiers in field names 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Test"
LEFT_BRACE:"{"
FIELDS:"FIELDS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
INTEGER:"1"
SEMICOLON:";"
SEMICOLON:";"
BEGIN:"BEGIN"
SEMICOLON:";"
INTEGER_TYPE:"Integer"
RIGHT_BRACE:"}"
LEFT_BRACE:"{"
INTEGER:"2"
SEMICOLON:";"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
INTEGER_TYPE:"Integer"
RIGHT_BRACE:"}"
LEFT_BRACE:"{"
INTEGER:"3"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"CODE"
SEMICOLON:";"
INTEGER_TYPE:"Integer"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Context-Dependent Tokenization should tokenize section keywords in field names 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Test"
LEFT_BRACE:"{"
FIELDS:"FIELDS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
INTEGER:"1"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"PROPERTIES"
SEMICOLON:";"
INTEGER_TYPE:"Integer"
RIGHT_BRACE:"}"
LEFT_BRACE:"{"
INTEGER:"2"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"FIELDGROUPS"
SEMICOLON:";"
INTEGER_TYPE:"Integer"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Context-Dependent Tokenization should tokenize trigger property with BEGIN/END as keywords 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Customer"
LEFT_BRACE:"{"
FIELDS:"FIELDS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
INTEGER:"1"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"No"
DOT:"."
SEMICOLON:";"
IDENTIFIER:"Code20"
SEMICOLON:";"
IDENTIFIER:"OnValidate"
EQUAL:"="
BEGIN:"BEGIN"
IDENTIFIER:"TESTFIELD"
LEFT_PAREN:"("
IDENTIFIER:"Name"
RIGHT_PAREN:")"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Core Object Structures should tokenize complete table with all sections 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Customer"
LEFT_BRACE:"{"
OBJECT_PROPERTIES:"OBJECT-PROPERTIES"
LEFT_BRACE:"{"
DATE_TYPE:"Date"
EQUAL:"="
DECIMAL:"14.01"
DOT:"."
INTEGER:"26"
SEMICOLON:";"
RIGHT_BRACE:"}"
PROPERTIES:"PROPERTIES"
LEFT_BRACE:"{"
IDENTIFIER:"Caption"
EQUAL:"="
IDENTIFIER:"Customer"
SEMICOLON:";"
RIGHT_BRACE:"}"
FIELDS:"FIELDS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
INTEGER:"1"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"No"
DOT:"."
SEMICOLON:";"
IDENTIFIER:"Code20"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
KEYS:"KEYS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
SEMICOLON:";"
IDENTIFIER:"No"
DOT:"."
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
CODE:"CODE"
LEFT_BRACE:"{"
BEGIN:"BEGIN"
END:"END"
DOT:"."
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Core Object Structures should tokenize minimal object 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
LEFT_BRACE:"{"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Core Object Structures should tokenize object with CODE section and triggers 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Customer"
LEFT_BRACE:"{"
CODE:"CODE"
LEFT_BRACE:"{"
BEGIN:"BEGIN"
END:"END"
DOT:"."
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Core Object Structures should tokenize object with FIELDS section 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Customer"
LEFT_BRACE:"{"
FIELDS:"FIELDS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
INTEGER:"1"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"No"
DOT:"."
SEMICOLON:";"
IDENTIFIER:"Code20"
RIGHT_BRACE:"}"
LEFT_BRACE:"{"
INTEGER:"2"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"Name"
SEMICOLON:";"
IDENTIFIER:"Text50"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Core Object Structures should tokenize object with OBJECT-PROPERTIES section 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Customer"
LEFT_BRACE:"{"
OBJECT_PROPERTIES:"OBJECT-PROPERTIES"
LEFT_BRACE:"{"
DATE_TYPE:"Date"
EQUAL:"="
DECIMAL:"14.01"
DOT:"."
INTEGER:"26"
SEMICOLON:";"
TIME_TYPE:"Time"
EQUAL:"="
INTEGER:"12"
COLON:":"
INTEGER:"00"
COLON:":"
INTEGER:"00"
SEMICOLON:";"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Core Object Structures should tokenize object with PROPERTIES section 1`] = `
"OBJECT:"OBJECT"
TABLE:"Table"
INTEGER:"18"
IDENTIFIER:"Customer"
LEFT_BRACE:"{"
PROPERTIES:"PROPERTIES"
LEFT_BRACE:"{"
IDENTIFIER:"DataPerCompany"
EQUAL:"="
IDENTIFIER:"Yes"
SEMICOLON:";"
IDENTIFIER:"Caption"
EQUAL:"="
IDENTIFIER:"Customer"
SEMICOLON:";"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize AL-only access modifiers 1`] = `
"AL_ONLY_ACCESS_MODIFIER:"internal"
AL_ONLY_ACCESS_MODIFIER:"protected"
AL_ONLY_ACCESS_MODIFIER:"public"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize AL-only keywords 1`] = `
"AL_ONLY_KEYWORD:"enum"
AL_ONLY_KEYWORD:"interface"
AL_ONLY_KEYWORD:"extends"
AL_ONLY_KEYWORD:"implements"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize C-style comment 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
INTEGER:"5"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize DATE literal (long format MMDDYYYY) 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
DATE:"06012020D"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize DATE literal (short format MMDDYY) 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
DATE:"060120D"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize DateTime literal 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
DATETIME:"060120D120000T"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize Format/Evaluate compound property 1`] = `
"OBJECT:"OBJECT"
XMLPORT:"XMLport"
INTEGER:"50000"
IDENTIFIER:"Test"
LEFT_BRACE:"{"
ELEMENTS:"ELEMENTS"
LEFT_BRACE:"{"
LEFT_BRACE:"{"
INTEGER:"1"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"Root"
SEMICOLON:";"
SEMICOLON:";"
IDENTIFIER:"Format/Evaluate"
EQUAL:"="
IDENTIFIER:"XML"
IDENTIFIER:"Format/Evaluate"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize OBJECT-PROPERTIES compound keyword 1`] = `
"OBJECT_PROPERTIES:"OBJECT-PROPERTIES"
LEFT_BRACE:"{"
DATE_TYPE:"Date"
EQUAL:"="
DECIMAL:"14.01"
DOT:"."
INTEGER:"26"
SEMICOLON:";"
RIGHT_BRACE:"}"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize TEMPORARY keyword in variable declaration 1`] = `
"IDENTIFIER:"TempCustomer"
UNKNOWN:"@"
INTEGER:"1000"
COLON:":"
TEMPORARY:"TEMPORARY"
RECORD:"Record"
INTEGER:"18"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize TIME literal 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
TIME:"120000T"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize boolean operators 1`] = `
"IDENTIFIER:"result"
ASSIGN:":="
LEFT_PAREN:"("
IDENTIFIER:"a"
AND:"AND"
IDENTIFIER:"b"
RIGHT_PAREN:")"
OR:"OR"
LEFT_PAREN:"("
IDENTIFIER:"c"
XOR:"XOR"
IDENTIFIER:"d"
RIGHT_PAREN:")"
AND:"AND"
LEFT_PAREN:"("
NOT:"NOT"
IDENTIFIER:"e"
RIGHT_PAREN:")"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize comparison operators 1`] = `
"BEGIN:"BEGIN"
IF:"IF"
LEFT_PAREN:"("
IDENTIFIER:"x"
EQUAL:"="
IDENTIFIER:"y"
RIGHT_PAREN:")"
AND:"AND"
LEFT_PAREN:"("
IDENTIFIER:"a"
NOT_EQUAL:"<>"
IDENTIFIER:"b"
RIGHT_PAREN:")"
AND:"AND"
LEFT_PAREN:"("
IDENTIFIER:"c"
LESS:"<"
IDENTIFIER:"d"
RIGHT_PAREN:")"
AND:"AND"
LEFT_PAREN:"("
IDENTIFIER:"e"
LESS_EQUAL:"<="
IDENTIFIER:"f"
RIGHT_PAREN:")"
AND:"AND"
LEFT_PAREN:"("
IDENTIFIER:"g"
GREATER:">"
IDENTIFIER:"h"
RIGHT_PAREN:")"
AND:"AND"
LEFT_PAREN:"("
IDENTIFIER:"i"
GREATER_EQUAL:">="
IDENTIFIER:"j"
RIGHT_PAREN:")"
THEN:"THEN"
EXIT:"EXIT"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize compound assignment operators 1`] = `
"BEGIN:"BEGIN"
IDENTIFIER:"x"
PLUS_ASSIGN:"+="
INTEGER:"5"
SEMICOLON:";"
IDENTIFIER:"y"
MINUS_ASSIGN:"-="
INTEGER:"3"
SEMICOLON:";"
IDENTIFIER:"z"
MULTIPLY_ASSIGN:"*="
INTEGER:"2"
SEMICOLON:";"
IDENTIFIER:"w"
DIVIDE_ASSIGN:"/="
INTEGER:"4"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize decimal numbers 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
DECIMAL:"123.45"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize mixed arithmetic operators 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
LEFT_PAREN:"("
IDENTIFIER:"a"
PLUS:"+"
IDENTIFIER:"b"
RIGHT_PAREN:")"
MULTIPLY:"*"
IDENTIFIER:"c"
DIVIDE:"/"
IDENTIFIER:"d"
MINUS:"-"
IDENTIFIER:"e"
MOD:"MOD"
IDENTIFIER:"f"
DIV:"DIV"
IDENTIFIER:"g"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize multi-line string literal 1`] = `
"BEGIN:"BEGIN"
IDENTIFIER:"MESSAGE"
LEFT_PAREN:"("
STRING:"Line 1\\nLine 2\\nLine 3"
RIGHT_PAREN:")"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize preprocessor directives 1`] = `
"PREPROCESSOR_DIRECTIVE:"#if"
IDENTIFIER:"DEBUG"
IDENTIFIER:"MESSAGE"
LEFT_PAREN:"("
STRING:"Debug mode"
RIGHT_PAREN:")"
SEMICOLON:";"
PREPROCESSOR_DIRECTIVE:"#endif"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize quoted identifier 1`] = `
"QUOTED_IDENTIFIER:"Field Name"
ASSIGN:":="
INTEGER:"5"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize quoted identifier with special characters 1`] = `
"QUOTED_IDENTIFIER:"Field/Name-123"
ASSIGN:":="
INTEGER:"5"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize range operator (..) 1`] = `
"IDENTIFIER:"Customer"
DOT:"."
IDENTIFIER:"SETRANGE"
LEFT_PAREN:"("
QUOTED_IDENTIFIER:"No."
COMMA:","
STRING:"1000"
DOTDOT:".."
STRING:"2000"
RIGHT_PAREN:")"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize scope operator (::) 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
IDENTIFIER:"Status"
DOUBLE_COLON:"::"
IDENTIFIER:"Open"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize single-line comment 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
INTEGER:"5"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize string literal with escaped quotes 1`] = `
"BEGIN:"BEGIN"
IDENTIFIER:"MESSAGE"
LEFT_PAREN:"("
STRING:"don't"
RIGHT_PAREN:")"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize ternary operator (not supported in C/AL) 1`] = `
"IDENTIFIER:"result"
ASSIGN:":="
IDENTIFIER:"condition"
TERNARY_OPERATOR:"?"
IDENTIFIER:"trueValue"
COLON:":"
IDENTIFIER:"falseValue"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize undefined DATE literal 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
DATE:"0D"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize undefined DateTime literal 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
DATETIME:"0DT"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize undefined TIME literal 1`] = `
"IDENTIFIER:"x"
ASSIGN:":="
TIME:"0T"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Edge Cases should tokenize variable with @ number 1`] = `
"IDENTIFIER:"MyVar"
UNKNOWN:"@"
INTEGER:"1000"
COLON:":"
INTEGER_TYPE:"Integer"
SEMICOLON:";"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize CASE statement 1`] = `
"BEGIN:"BEGIN"
CASE:"CASE"
IDENTIFIER:"Status"
OF:"OF"
INTEGER:"0"
COLON:":"
IDENTIFIER:"Message"
ASSIGN:":="
STRING:"Open"
SEMICOLON:";"
INTEGER:"1"
COLON:":"
IDENTIFIER:"Message"
ASSIGN:":="
STRING:"Closed"
SEMICOLON:";"
INTEGER:"2"
COLON:":"
BEGIN:"BEGIN"
IDENTIFIER:"Message"
ASSIGN:":="
STRING:"Processing"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize FOR loop 1`] = `
"BEGIN:"BEGIN"
FOR:"FOR"
IDENTIFIER:"i"
ASSIGN:":="
INTEGER:"1"
TO:"TO"
INTEGER:"10"
DO:"DO"
BEGIN:"BEGIN"
IDENTIFIER:"x"
ASSIGN:":="
IDENTIFIER:"x"
PLUS:"+"
IDENTIFIER:"i"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize IF/THEN/ELSE structure 1`] = `
"BEGIN:"BEGIN"
IF:"IF"
IDENTIFIER:"x"
GREATER:">"
INTEGER:"0"
THEN:"THEN"
IDENTIFIER:"y"
ASSIGN:":="
INTEGER:"1"
ELSE:"ELSE"
IDENTIFIER:"y"
ASSIGN:":="
INTEGER:"2"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize REPEAT/UNTIL loop 1`] = `
"BEGIN:"BEGIN"
REPEAT:"REPEAT"
IDENTIFIER:"x"
ASSIGN:":="
IDENTIFIER:"x"
PLUS:"+"
INTEGER:"1"
SEMICOLON:";"
UNTIL:"UNTIL"
IDENTIFIER:"x"
GREATER_EQUAL:">="
INTEGER:"10"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize WHILE loop 1`] = `
"BEGIN:"BEGIN"
WHILE:"WHILE"
IDENTIFIER:"x"
LESS:"<"
INTEGER:"10"
DO:"DO"
BEGIN:"BEGIN"
IDENTIFIER:"x"
ASSIGN:":="
IDENTIFIER:"x"
PLUS:"+"
INTEGER:"1"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize deeply nested BEGIN/END blocks (3 levels) 1`] = `
"BEGIN:"BEGIN"
IDENTIFIER:"x"
ASSIGN:":="
INTEGER:"1"
SEMICOLON:";"
BEGIN:"BEGIN"
IDENTIFIER:"y"
ASSIGN:":="
INTEGER:"2"
SEMICOLON:";"
BEGIN:"BEGIN"
IDENTIFIER:"z"
ASSIGN:":="
INTEGER:"3"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize nested BEGIN/END blocks (2 levels) 1`] = `
"BEGIN:"BEGIN"
IDENTIFIER:"x"
ASSIGN:":="
INTEGER:"1"
SEMICOLON:";"
BEGIN:"BEGIN"
IDENTIFIER:"y"
ASSIGN:":="
INTEGER:"2"
SEMICOLON:";"
END:"END"
SEMICOLON:";"
IDENTIFIER:"z"
ASSIGN:":="
INTEGER:"3"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize nested IF/THEN/ELSE 1`] = `
"BEGIN:"BEGIN"
IF:"IF"
IDENTIFIER:"x"
GREATER:">"
INTEGER:"0"
THEN:"THEN"
BEGIN:"BEGIN"
IF:"IF"
IDENTIFIER:"y"
GREATER:">"
INTEGER:"0"
THEN:"THEN"
IDENTIFIER:"z"
ASSIGN:":="
INTEGER:"1"
ELSE:"ELSE"
IDENTIFIER:"z"
ASSIGN:":="
INTEGER:"2"
SEMICOLON:";"
END:"END"
ELSE:"ELSE"
IDENTIFIER:"z"
ASSIGN:":="
INTEGER:"3"
SEMICOLON:";"
END:"END"
EOF:"""
`;

exports[`Lexer Tokenization Snapshots Nested Blocks and Control Flow should tokenize simple BEGIN/END block 1`] = `
"BEGIN:"BEGIN"
IDENTIFIER:"x"
ASSIGN:":="
INTEGER:"5"
SEMICOLON:";"
END:"END"
EOF:"""
`;
